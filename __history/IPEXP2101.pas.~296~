unit IPEXP2101;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, ComCtrls, DRLabel, StdCtrls, ExtCtrls, ToolWin, ImgList, Menus, DB,
  DBAccess, Uni, Buttons, plFileDialog, IniFiles, MemDS, DRRequest,
  ActiveX, ShlObj, ComObj, ExtDlgs, StrUtils, DateUtils,
  Winsock, NB30;

type
  // ====== Data Structures ======
  TWorkRow = record
    KMSEQNO: string;
    SEIZONO: string;
    HINNM1: string;
    HINNM2: string;
    ItemCD: string;
    DEADLINE: TDateTime;
    MfgClassific: string;
    MeduimProcess: string; // เก็บค่า Process ที่รวมมาแล้ว
    Remark: string;        // (โครงสร้างเดิม เก็บไว้แต่ไม่ใช้)
    WorkDate: TDateTime;
    MAN: Double;
    UNMAN: Double;
  end;
  TWorkRowArray = array of TWorkRow;

  // Date Map Structure
  TDateMap = record
    ColIndex: Integer;
    StartDate: TDateTime;
    EndDate: TDateTime;
  end;
  TDateMapArray = array of TDateMap;

  TForm1 = class(TForm)
    panTitle: TPanel;
    DRTitle1: TDRTitle;
    panMain: TPanel;
    stbBase: TDRStatusBar;
    DrImageList: TImageList;
    Database_Log: TUniConnection;
    CoolBar1: TCoolBar;
    ToolBar1: TToolBar;
    btnExport: TDRToolButton;
    btnClose: TDRToolButton;
    DRImageList2: TImageList;
    edtPATH: TEdit;
    btnPATH: TDRToolButton;
    ToolBar3: TToolBar;
    lbEmpty: TDRLabel;
    lbExcel: TDRLabel;
    qSelect: TDRQuery;
    qLog: TDRQuery;
    OpenTextFileDialog: TOpenTextFileDialog;
    MainMenu1: TMainMenu;
    File1: TMenuItem;
    Export1: TMenuItem;
    Settings1: TMenuItem;
    Close1: TMenuItem;

    procedure FormCreate(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure btnCloseClick(Sender: TObject);
    procedure btnPATHClick(Sender: TObject);
    procedure btnExportClick(Sender: TObject);
    procedure Close1Click(Sender: TObject);
    procedure Export1Click(Sender: TObject);
    procedure FormShow(Sender: TObject);

  private
    FWorkData: TWorkRowArray;
    FWorkDataCount: Integer;

    function IniFileName: string;
    procedure LoadSettings;
    procedure SaveSettings;
    function GetDateStamp: string;
    function GetAppVersion: string;
    
    // System Helpers
    function GetLocalIP: string;
    function GetPCName: string;
    function GetWindowsUser: string;
    function GetMacAddress: string;
    function GetLoginUserFromIni: string; 
    
    // Logging
    procedure InsertLogData(const AMsg: string; ALogKbn: Integer); // 0=Info, 1=Warn, 2=Err
    procedure BuildExportYears(AList: TStrings);
    function BuildOutFileName(const AFolder: string; AYear: Integer): string;
    procedure ExportBlobToExcelFile(const ABlobID, AOutFile: string);
    procedure DoExportAll;
   procedure LoadWorkData(AYear: Integer);

    procedure FillTemplateHeaders(const AFileName: string; AYear: Integer);
    function BuildDateMapping(const AWS: OleVariant; AYear: Integer): TDateMapArray;

  public
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

uses AttraLib, DataModule, Class_DRSetUp;

// ============================================================================
//  ✅ Constants for Japanese Handling
// ============================================================================
const
  SHEET_NAME_JP = #$5DE5#$7A0B; // "工程"
  SHEET_NAME_EN = 'koutei';
  FILE_NAME_JP  = #$8CA0#$8377#$7387#$8868; // "負荷率表"

// ============================================================================
//  Interface for IFileDialog
// ============================================================================
type
  IFileDialog = interface(IUnknown)
    ['{42F85136-DB7E-439C-85F1-E4075D135FC8}']
    function Show(hwndOwner: HWND): HRESULT; stdcall;
    function SetFileTypes(cFileTypes: UINT; rgFilterSpec: Pointer): HRESULT; stdcall;
    function SetFileTypeIndex(iFileType: UINT): HRESULT; stdcall;
    function GetFileTypeIndex(out piFileType: UINT): HRESULT; stdcall;
    function Advise(pfde: IUnknown; out pdwCookie: DWORD): HRESULT; stdcall;
    function Unadvise(dwCookie: DWORD): HRESULT; stdcall;
    function SetOptions(fos: DWORD): HRESULT; stdcall;
    function GetOptions(out pfos: DWORD): HRESULT; stdcall;
    function SetDefaultFolder(psi: IUnknown): HRESULT; stdcall;
    function SetFolder(psi: IUnknown): HRESULT; stdcall;
    function GetFolder(out ppsi: IUnknown): HRESULT; stdcall;
    function GetCurrentSelection(out ppsi: IUnknown): HRESULT; stdcall;
    function SetFileName(pszName: PWideChar): HRESULT; stdcall;
    function GetFileName(out pszName: PWideChar): HRESULT; stdcall;
    function SetTitle(pszTitle: PWideChar): HRESULT; stdcall;
    function SetOkButtonLabel(pszText: PWideChar): HRESULT; stdcall;
    function SetFileNameLabel(pszLabel: PWideChar): HRESULT; stdcall;
    function GetResult(out ppsi: IUnknown): HRESULT; stdcall;
    function AddPlace(psi: IUnknown; fdap: DWORD): HRESULT; stdcall;
    function SetDefaultExtension(pszDefaultExtension: PWideChar): HRESULT; stdcall;
    function Close(hr: HRESULT): HRESULT; stdcall;
    function SetClientGuid(const guid: TGUID): HRESULT; stdcall;
    function ClearClientData: HRESULT; stdcall;
    function SetFilter(pFilter: IUnknown): HRESULT; stdcall;
  end;

  IShellItem = interface(IUnknown)
    ['{43826D1E-E718-42EE-BC55-A1E261C37BFE}']
    function BindToHandler(pbc: Pointer; const bhid: TGUID; const riid: TGUID; out ppv): HRESULT; stdcall;
    function GetParent(out ppsi: IShellItem): HRESULT; stdcall;
    function GetDisplayName(sigdnName: DWORD; out ppszName: PWideChar): HRESULT; stdcall;
    function GetAttributes(sfgaoMask: DWORD; out psfgaoAttribs: DWORD): HRESULT; stdcall;
    function Compare(psi: IShellItem; hint: DWORD; out piOrder: Integer): HRESULT; stdcall;
  end;

const
  CLSID_FileOpenDialog: TGUID = '{DC1C5A9C-E88A-4DDE-A5A1-60F82A20AEF7}';
  SIGDN_FILESYSPATH       = $80058000;
  FOS_PICKFOLDERS         = $00000020;
  FOS_FORCEFILESYSTEM     = $00000040;
  FOS_PATHMUSTEXIST       = $00000800;

function SHCreateItemFromParsingName(pszPath: PWideChar; pbc: Pointer;
  const riid: TGUID; out ppv): HRESULT; stdcall;
  external 'shell32.dll' name 'SHCreateItemFromParsingName';

// ============================================================================
//  General Helper Functions
// ============================================================================

function GetCellText(const WS: OleVariant; Row, Col: Integer): string;
var
  C: OleVariant;
begin
  try
    C := WS.Cells[Row, Col];
    Result := Trim(VarToStr(C)); 
  except
    Result := '';
  end;
end;

function ExeFolder: string;
begin
  Result := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName));
end;

procedure SaveIniLines(const AFileName, ASection: string; ALines: TStrings);
var
  Ini: TIniFile;
  i: Integer;
  Key: string;
begin
  Ini := TIniFile.Create(AFileName);
  try
    Ini.EraseSection(ASection);
    Ini.WriteInteger(ASection, 'Count', ALines.Count);
    for i := 0 to ALines.Count - 1 do
    begin
      Key := Format('Line%.4d', [i + 1]);
      Ini.WriteString(ASection, Key, ALines[i]);
    end;
  finally
    Ini.Free;
  end;
end;

procedure SaveIniText(const AFileName, ASection: string; const AText: string);
var
  SL: TStringList;
begin
  SL := TStringList.Create;
  try
    SL.Text := AText;
    SaveIniLines(AFileName, ASection, SL);
  finally
    SL.Free;
  end;
end;

procedure SaveStringToFile(const AFileName, AText: string);
var
  SL: TStringList;
begin
  SL := TStringList.Create;
  try
    SL.Text := AText;
    SL.SaveToFile(AFileName);
  finally
    SL.Free;
  end;
end;

function GetTempXlsxFileName: string;
var
  PathBuf: array[0..MAX_PATH] of Char;
begin
  if GetTempPath(MAX_PATH, @PathBuf) > 0 then
  begin
    Result := IncludeTrailingPathDelimiter(PChar(@PathBuf)) +
              'IPEXP2101_template_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xlsx';
  end
  else
  begin
    Result := ExtractFilePath(Application.ExeName) +
              'IPEXP2101_template_' + FormatDateTime('yyyymmdd_hhnnss', Now) + '.xlsx';
  end;
end;

function SqlQuotedList(const L: TStrings): string;
var
  i: Integer;
  s: string;
begin
  Result := '';
  for i := 0 to L.Count - 1 do
  begin
    s := Trim(L[i]);
    if s = '' then Continue;
    s := StringReplace(s, '''', '''''', [rfReplaceAll]);
    if Result <> '' then Result := Result + ',';
    Result := Result + '''' + s + '''';
  end;
  if Result = '' then Result := '''__NO_MATCH__''';
end;

function MakeUniqueList(const Src: TStrings): TStringList;
var
  i: Integer;
  s: string;
begin
  Result := TStringList.Create;
  Result.Sorted := True;
  Result.Duplicates := dupIgnore;
  for i := 0 to Src.Count - 1 do
  begin
    s := UpperCase(Trim(Src[i]));
    if s <> '' then Result.Add(s);
  end;
end;

function BrowseFolder_Explorer(const ATitle, AInitialFolder: string; out ASelectedFolder: string): Boolean;
var
  Dlg: IFileDialog;
  Opt: DWORD;
  Item: IShellItem;
  WS: PWideChar;
begin
  Result := False;
  ASelectedFolder := '';
  if Failed(CoCreateInstance(CLSID_FileOpenDialog, nil, CLSCTX_INPROC_SERVER, IFileDialog, Dlg)) then Exit;
  Dlg.SetTitle(PWideChar(WideString(ATitle)));
  if Succeeded(Dlg.GetOptions(Opt)) then
    Dlg.SetOptions(Opt or FOS_PICKFOLDERS or FOS_FORCEFILESYSTEM or FOS_PATHMUSTEXIST);
  if (AInitialFolder <> '') and DirectoryExists(AInitialFolder) then
    if Succeeded(SHCreateItemFromParsingName(PWideChar(WideString(AInitialFolder)), nil, IShellItem, Item)) then
      Dlg.SetFolder(Item);
  if Succeeded(Dlg.Show(Application.Handle)) then
  begin
    if Succeeded(Dlg.GetResult(IUnknown(Item))) and (Item <> nil) then
    begin
      WS := nil;
      if Succeeded(Item.GetDisplayName(SIGDN_FILESYSPATH, WS)) and (WS <> nil) then
      begin
        ASelectedFolder := WS;
        CoTaskMemFree(WS);
        Result := True;
      end;
    end;
  end;
end;

// ============================================================================
//  Network & System Info Helpers
// ============================================================================

function TForm1.GetPCName: string;
var
  Buffer: array[0..MAX_COMPUTERNAME_LENGTH + 1] of Char;
  Size: DWORD;
begin
  Size := Length(Buffer);
  if GetComputerName(Buffer, Size) then
    Result := StrPas(Buffer)
  else
    Result := 'UnknownPC';
end;

function TForm1.GetWindowsUser: string;
var
  Buffer: array[0..255] of Char;
  Size: DWORD;
begin
  Size := 256;
  if GetUserName(Buffer, Size) then
    Result := StrPas(Buffer)
  else
    Result := 'UnknownUser';
end;

function TForm1.GetLoginUserFromIni: string;
var
  Ini: TIniFile;
  IniPath: string;
begin
  Result := '';
  IniPath := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName)) + 'Setup\DRLOGIN.ini';
  if FileExists(IniPath) then
  begin
    Ini := TIniFile.Create(IniPath);
    try
      Result := Ini.ReadString('TLogOnForm', 'CD2', '');
    finally
      Ini.Free;
    end;
  end;
end;

function TForm1.GetLocalIP: string;
var
  WSAData: TWSAData;
  HostEnt: PHostEnt;
  Name: array[0..255] of Char;
  InAddr: TInAddr;
begin
  Result := '0.0.0.0';
  if WSAStartup($0101, WSAData) = 0 then
  try
    if GetHostname(Name, SizeOf(Name)) = 0 then
    begin
      HostEnt := GetHostByName(Name);
      if HostEnt <> nil then
      begin
        InAddr := PInAddr(HostEnt^.h_addr_list^)^;
        Result := string(inet_ntoa(InAddr));
      end;
    end;
  finally
    WSACleanup;
  end;
end;

function TForm1.GetMacAddress: string;
const
  NCBENUM  = #$37;
  NCBRESET = #$32;
  NCBASTAT = #$33;
var
  NCB: TNCB;
  Adapter: TADAPTERSTATUS;
  LanaEnum: TLANAENUM;
  intIdx: Integer;
  strTemp: string;
begin
  Result := '00-00-00-00-00-00';
  try
    FillChar(NCB, SizeOf(NCB), 0);
    NCB.ncb_command := NCBENUM;
    NCB.ncb_buffer := @LanaEnum;
    NCB.ncb_length := SizeOf(LanaEnum);
    Netbios(@NCB);

    if Ord(LanaEnum.length) > 0 then
    begin
      FillChar(NCB, SizeOf(NCB), 0);
      NCB.ncb_command := NCBRESET;
      NCB.ncb_lana_num := LanaEnum.lana[0];
      Netbios(@NCB);

      FillChar(NCB, SizeOf(NCB), 0);
      NCB.ncb_command := NCBASTAT;
      NCB.ncb_lana_num := LanaEnum.lana[0];
      StrPCopy(NCB.ncb_callname, '*');
      NCB.ncb_buffer := @Adapter;
      NCB.ncb_length := SizeOf(Adapter);
      Netbios(@NCB);

      strTemp := '';
      for intIdx := 0 to 5 do
      begin
        strTemp := strTemp + IntToHex(Integer(Adapter.adapter_address[intIdx]), 2);
        if intIdx < 5 then strTemp := strTemp + '-';
      end;
      Result := strTemp;
    end;
  except
  end;
end;

// ============================================================================
//  Database Logging Procedures
// ============================================================================
procedure TForm1.InsertLogData(const AMsg: string; ALogKbn: Integer);
var
  TempQ: TDRQuery;
begin
  TempQ := TDRQuery.Create(nil);
  try
    try
      TempQ.Connection := qLog.Connection;
      TempQ.Close;
      TempQ.SQL.Text :=
        'INSERT INTO LOGDATA (' +
        '  LOGYMD, LOGKBN, MESSAGE, PGNAME, PGVERSION, MESSAGEID, CONFIRM ' +
        ') VALUES (' +
        '  SYSDATE, :LOGKBN, :MESSAGE, :PGNAME, :PGVERSION, 0, 0)';
      TempQ.ParamByName('LOGKBN').AsInteger := ALogKbn; 
      TempQ.ParamByName('MESSAGE').AsString :=  AMsg;
      TempQ.ParamByName('PGNAME').AsString := ExtractFileName(Application.ExeName);
      TempQ.ParamByName('PGVERSION').AsString := GetAppVersion;
      TempQ.Open ;
      TempQ.ExecSQL;
    except
    end;
  finally
    TempQ.Free;
  end;
end;

// ============================================================================
//  Form Events & Main Logic
// ============================================================================

function TForm1.IniFileName: string;
begin
  Result := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName)) + 'IPEXP2100.ini';
end;

procedure TForm1.LoadSettings;
var Ini: TIniFile;
begin
  Ini := TIniFile.Create(IniFileName);
  try
    edtPATH.Text := Ini.ReadString('SETTING', 'EXPORT_PATH', '');
  finally
    Ini.Free;
  end;
end;

procedure TForm1.SaveSettings;
var Ini: TIniFile;
begin
  Ini := TIniFile.Create(IniFileName);
  try
    Ini.WriteString('SETTING', 'EXPORT_PATH', Trim(edtPATH.Text));
  finally
    Ini.Free;
  end;
end;

function TForm1.GetAppVersion: string;
var
  VerInfoSize, VerValueSize, Dummy: DWORD;
  VerInfo: Pointer;
  VerValue: PVSFixedFileInfo;
begin
  Result := '';
  VerInfoSize := GetFileVersionInfoSize(PChar(Application.ExeName), Dummy);
  if VerInfoSize > 0 then
  begin
    GetMem(VerInfo, VerInfoSize);
    try
      if GetFileVersionInfo(PChar(Application.ExeName), 0, VerInfoSize, VerInfo) then
      begin
        if VerQueryValue(VerInfo, '\', Pointer(VerValue), VerValueSize) then
        begin
          Result := Format('%d.%d.%d.%d', [
            HiWord(VerValue.dwFileVersionMS),
            LoWord(VerValue.dwFileVersionMS),
            HiWord(VerValue.dwFileVersionLS),
            LoWord(VerValue.dwFileVersionLS)
          ]);
        end;
      end;
    finally
      FreeMem(VerInfo, VerInfoSize);
    end;
  end;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  LoadSettings;
  try
    AttraConnectDataArea(qLog.Connection);
    InsertLogData('負荷率表出力(' + GetAppVersion + ')を起動しました', 0);
  except
  end;
end;

procedure TForm1.FormShow(Sender: TObject);
var
  VerStr, ExeName: string;
begin
  VerStr := GetAppVersion;
  ExeName := ExtractFileName(Application.ExeName);

  if VerStr = '' then VerStr := 'No Version Info';

  if stbBase.Panels.Count > 0 then
    stbBase.Panels[0].Text := ExeName + ' (Ver ' + VerStr + ')'
  else
  begin
    stbBase.SimplePanel := True;
    stbBase.SimpleText := ExeName + ' (Ver ' + VerStr + ')';
  end;
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction); 
begin 
  InsertLogData('負荷率表出力(' + GetAppVersion + ')を終了しました', 0);
  SaveSettings; 
end;

procedure TForm1.btnCloseClick(Sender: TObject); begin Close; end;
procedure TForm1.Close1Click(Sender: TObject); begin Close; end;
procedure TForm1.Export1Click(Sender: TObject); begin DoExportAll; end;
procedure TForm1.btnExportClick(Sender: TObject); begin DoExportAll; end;

procedure TForm1.btnPATHClick(Sender: TObject);
var Sel: string;
begin
  if BrowseFolder_Explorer('Select export folder', Trim(edtPATH.Text), Sel) then
    edtPATH.Text := ExcludeTrailingPathDelimiter(Sel);
end;

function TForm1.GetDateStamp: string;
begin
  Result := FormatDateTime('yyyymmdd', Date);
end;

procedure TForm1.BuildExportYears(AList: TStrings);
var
  Y, M, D: Word;
  CurYear: Integer;
begin
  AList.Clear;
  DecodeDate(Date, Y, M, D);
  CurYear := Y;
  AList.Add(IntToStr(CurYear));
  AList.Add(IntToStr(CurYear + 1));
  if M = 1 then AList.Add(IntToStr(CurYear - 1));
end;

function TForm1.BuildOutFileName(const AFolder: string; AYear: Integer): string;
var
  TestName: string;
begin
  TestName := FILE_NAME_JP + '_' + IntToStr(AYear) + '_' + GetDateStamp + '.xlsx';

  if Pos('?', TestName) > 0 then
  begin
    Result := IncludeTrailingPathDelimiter(AFolder) + 'LoadFactor_' + IntToStr(AYear) + '_' + GetDateStamp + '.xlsx';
  end
  else
  begin
    Result := IncludeTrailingPathDelimiter(AFolder) + TestName;
  end;
end;

function LoadTemplateEList_FirstBlockByB_NoValue(const AWS: OleVariant; StartRow: Integer): TStringList;
var
  r: Integer;
  vB, vE: string;
  Started: Boolean;
  function IsDashRow(const S: string): Boolean; begin Result := (S = '-') or (S = '－'); end;
begin
  Result := TStringList.Create;
  Result.Sorted := False;
  r := StartRow;
  Started := False;
  while True do
  begin
    vB := GetCellText(AWS, r, 2);
    vE := GetCellText(AWS, r, 5);
    if IsDashRow(vB) then
    begin
      if vE <> '' then Result.Add(vE);
      if not Started then begin Started := True; Inc(r); Continue; end else Break;
    end;
    if Started and (vE <> '') then Result.Add(vE);
    Inc(r);
    if r > StartRow + 5000 then Break;
  end;
end;

// ============================================================================
//  Logic: Load Work Data
// ============================================================================
procedure TForm1.LoadWorkData(AYear: Integer);
var
  Row: TWorkRow;
  Cap: Integer;
  TempFile, YearStr, InList, OutFolder, LogFile, ListFile: string;
  XLApp, WB, WS: OleVariant;
  BlobField: TBlobField; BlobStream: TStream; FileStream: TFileStream;
  EList, EUni: TStringList;

  function SafeStrField(const AName: string): string; begin try Result := Trim(qLog.FieldByName(AName).AsString); except Result := ''; end; end;
  function SafeDateField(const AName: string): TDateTime; begin try if qLog.FieldByName(AName).IsNull then Result := 0 else Result := qLog.FieldByName(AName).AsDateTime; except Result := 0; end; end;
  function SafeDoubleField(const AName: string): Double; begin try if qLog.FieldByName(AName).IsNull then Result := 0 else Result := qLog.FieldByName(AName).AsFloat; except Result := 0; end; end;

begin
  SetLength(FWorkData, 0); FWorkDataCount := 0; Cap := 0;

  OutFolder := Trim(edtPATH.Text);
  if (OutFolder <> '') and DirectoryExists(OutFolder) then OutFolder := IncludeTrailingPathDelimiter(OutFolder) else OutFolder := '';
  LogFile := IniFileName;

  EList := nil; EUni := nil; XLApp := Unassigned; InList := '''__NO_MATCH__''';
  TempFile := '';
  try
    YearStr := IntToStr(AYear);

    TempFile := GetTempXlsxFileName;
    qSelect.Close;
    qSelect.SQL.Text := 'select BINARYDATA from BLOBDATA where BLOBID = ' + QuotedStr(YearStr);
    qSelect.Open;
    if not qSelect.IsEmpty then
    begin
      BlobField := qSelect.FieldByName('BINARYDATA') as TBlobField;
      if BlobField.IsNull then raise Exception.Create('BLOBID ' + YearStr + ' found but data is NULL.');
      BlobStream := qSelect.CreateBlobStream(BlobField, bmRead);
      try FileStream := TFileStream.Create(TempFile, fmCreate); try FileStream.CopyFrom(BlobStream, 0); finally FileStream.Free; end; finally BlobStream.Free; end;
      try
        XLApp := CreateOleObject('Excel.Application'); XLApp.DisplayAlerts := False; WB := XLApp.Workbooks.Open(TempFile);
        try WS := WB.Worksheets[SHEET_NAME_JP]; except try WS := WB.Worksheets[SHEET_NAME_EN]; except WB.Close(False); raise Exception.Create('Error: Sheet "' + '工程' + '" or "' + SHEET_NAME_EN + '" not found in template.'); end; end;

        EList := LoadTemplateEList_FirstBlockByB_NoValue(WS, 5);
        EUni := MakeUniqueList(EList);
        InList := SqlQuotedList(EUni);

        WB.Close(False);
      except
        on E: Exception do
        begin
          if not VarIsEmpty(XLApp) then XLApp.Quit;
          if OutFolder <> '' then SaveIniText(LogFile, 'ERROR_LOG', 'Warning: Failed to read Template. ' + E.Message);
          InsertLogData('内部エラー' + E.Message + 'が発生しました', 2);
          raise;
        end;
      end;
    end;
  finally
    if not VarIsEmpty(XLApp) then try XLApp.Quit; except end;
    if EUni <> nil then EUni.Free; if EList <> nil then EList.Free;
    if (TempFile <> '') and FileExists(TempFile) then DeleteFile(TempFile);
  end;

  // --- Query Data ---
  qLog.Close;
  qLog.SQL.Text :=
    'SELECT * FROM ((' +
    // Medium Process part...
    'SELECT MIN(kk.KMSEQNO) AS KMSEQNO, kk.SEIZONO, sz.hinnm1, sz.hinnm2, sz.HINSYUCD AS "Item CD", ' +
    'MIN(sz.KNOUKIYMD) AS "DEADLINE", s.SEIZOKBNNM AS "Mfg Classific", ' +
    'ktk.CYUNITEICD AS "Process", ' +
    'COALESCE(TRUNC(f.fukaymd), TRUNC(js.YMDE)) AS "Work Date", ' +
    'SUM(CASE WHEN f.fukaymd IS NOT NULL THEN (NVL(f.YUJINFUKA, 0) / 60) ' +
    'WHEN js.YMDE IS NOT NULL AND js.JKBN = ''4'' THEN ((NVL(js.jmaedanh, 0) + NVL(js.jyujinh, 0) + NVL(js.jatodanh, 0)) / 60) ELSE 0 END) AS "MAN", ' +
    'SUM(CASE WHEN f.fukaymd IS NOT NULL THEN (NVL(f.MUJINFUKA, 0) / 60) ' +
    'WHEN js.YMDE IS NOT NULL AND js.JKBN = ''4'' THEN (NVL(js.jmujinh, 0) / 60) ELSE 0 END) AS "UNMAN" ' +
    'FROM keikakumst kk LEFT JOIN keikakuopt ko ON kk.KMSEQNO = ko.KMSEQNO ' +
    'LEFT JOIN jisekidata js ON js.KMSEQNO = kk.KMSEQNO LEFT JOIN FUKADATA f ON f.KMSEQNO = kk.KMSEQNO ' +
    'LEFT JOIN kouteikmst ktk ON ktk.KEIKOTEICD = kk.keikoteicd LEFT JOIN kouteicmst kc ON kc.CYUNITEICD = ktk.CYUNITEICD ' +
    'LEFT JOIN seizomst sz ON kk.seizono = sz.seizono LEFT JOIN SEIZOKBNMST s ON sz.SEIZOKBN = s.SEIZOKBN ' +
    'WHERE sz.kanryoymd IS NULL AND ktk.CYUNITEICD IS NOT NULL AND (TRUNC(f.fukaymd) IS NOT NULL OR TRUNC(js.YMDE) IS NOT NULL) ' +
    'GROUP BY kk.SEIZONO, kc.bikou, sz.hinnm1, sz.hinnm2, sz.HINSYUCD, s.SEIZOKBNNM, ktk.CYUNITEICD, COALESCE(TRUNC(f.fukaymd), TRUNC(js.YMDE))) ' +
    'UNION ALL ' +
    '(SELECT MIN(kk.KMSEQNO) AS KMSEQNO, kk.SEIZONO, sz.hinnm1, sz.hinnm2, sz.HINSYUCD AS "Item CD", ' +
    'MIN(sz.KNOUKIYMD) AS "DEADLINE", s.SEIZOKBNNM AS "Mfg Classific", ' +
    'kc.bikou AS "Process", ' +
    'COALESCE(TRUNC(f.fukaymd), TRUNC(js.YMDE)) AS "Work Date", ' +
    'SUM(CASE WHEN f.fukaymd IS NOT NULL THEN (NVL(f.YUJINFUKA, 0) / 60) ' +
    'WHEN js.YMDE IS NOT NULL AND js.JKBN = ''4'' THEN ((NVL(js.jmaedanh, 0) + NVL(js.jyujinh, 0) + NVL(js.jatodanh, 0)) / 60) ELSE 0 END) AS "MAN", ' +
    'SUM(CASE WHEN f.fukaymd IS NOT NULL THEN (NVL(f.MUJINFUKA, 0) / 60) ' +
    'WHEN js.YMDE IS NOT NULL AND js.JKBN = ''4'' THEN (NVL(js.jmujinh, 0) / 60) ELSE 0 END) AS "UNMAN" ' +
    'FROM keikakumst kk LEFT JOIN keikakuopt ko ON kk.KMSEQNO = ko.KMSEQNO ' +
    'LEFT JOIN jisekidata js ON js.KMSEQNO = kk.KMSEQNO LEFT JOIN FUKADATA f ON f.KMSEQNO = kk.KMSEQNO ' +
    'LEFT JOIN kouteikmst ktk ON ktk.KEIKOTEICD = kk.keikoteicd LEFT JOIN kouteicmst kc ON kc.CYUNITEICD = ktk.CYUNITEICD ' +
    'LEFT JOIN seizomst sz ON kk.seizono = sz.seizono LEFT JOIN SEIZOKBNMST s ON sz.SEIZOKBN = s.SEIZOKBN ' +
    'WHERE sz.kanryoymd IS NULL AND ktk.CYUNITEICD IS NOT NULL AND (TRUNC(f.fukaymd) IS NOT NULL OR TRUNC(js.YMDE) IS NOT NULL) ' +
    'AND kc.bikou IS NOT NULL ' +
    'GROUP BY kk.SEIZONO, kc.bikou, sz.hinnm1, sz.hinnm2, sz.HINSYUCD, s.SEIZOKBNNM, ktk.CYUNITEICD, COALESCE(TRUNC(f.fukaymd), TRUNC(js.YMDE))) ' +
    ') WHERE TRIM(UPPER("Process")) IN (' + InList + ') ' +
    'AND TO_CHAR("Work Date", ''YYYY'') = ' + QuotedStr(YearStr) + ' ' +
    'ORDER BY SEIZONO, "Work Date"';

  if OutFolder <> '' then SaveIniText(LogFile, 'SQL_LOG', qLog.SQL.Text);

  try
    qLog.Open;
    while not qLog.Eof do
    begin
      Row.KMSEQNO := SafeStrField('KMSEQNO'); Row.SEIZONO := SafeStrField('SEIZONO');
      Row.HINNM1 := SafeStrField('hinnm1'); Row.HINNM2 := SafeStrField('hinnm2');
      Row.ItemCD := SafeStrField('Item CD'); Row.DEADLINE := SafeDateField('DEADLINE');
      Row.MfgClassific := SafeStrField('Mfg Classific');
      Row.MeduimProcess := SafeStrField('Process');
      Row.Remark := '';
      Row.WorkDate := SafeDateField('Work Date');
      Row.MAN := SafeDoubleField('MAN'); Row.UNMAN := SafeDoubleField('UNMAN');

      if FWorkDataCount >= Cap then begin if Cap=0 then Cap:=512 else Cap:=Cap*2; SetLength(FWorkData, Cap); end;
      FWorkData[FWorkDataCount] := Row; Inc(FWorkDataCount);
      qLog.Next;
    end;
    SetLength(FWorkData, FWorkDataCount);
  except
    on E: Exception do
    begin
      SetLength(FWorkData, 0); FWorkDataCount := 0;
      if OutFolder <> '' then 
        SaveIniText(LogFile, 'ERROR_LOG', qLog.SQL.Text + #13#10 + 'ERROR: ' + E.Message);
      InsertLogData('内部エラー' + E.Message + 'が発生しました', 2);
      MessageDlg('Error loading data from Database.' + #13#10 + 'Reason: ' + E.Message + #13#10 + 'Please check log file.', mtError, [mbOK], 0);
    end;
  end;
end;


// ============================================================================
//  Excel Logic: BuildDateMapping (Unchanged as requested)
// ============================================================================
function TForm1.BuildDateMapping(const AWS: OleVariant; AYear: Integer): TDateMapArray;
var
  c, iMonth, iDayStart, iDayEnd: Integer;
  Count, LastMonth: Integer;
  vMonth, vDS, vDE: OleVariant;
begin
  { เตรียม array ผลลัพธ์สูงสุด 60 ช่อง }
  SetLength(Result, 60);
  Count := 0;
  LastMonth := 0;

  { คอลัมน์ K = 11 → รวม 60 คอลัมน์ (K ถึง BR) }
  for c := 11 to 11 + 60 - 1 do
  begin
    { อ่านค่าจาก Excel }
    vMonth := AWS.Cells[2, c];  // row 2 = เดือน
    vDS    := AWS.Cells[3, c];  // row 3 = วันเริ่ม
    vDE    := AWS.Cells[4, c];  // row 4 = วันจบ

    { ---------- Month ---------- }
    { ถ้ามีค่าเดือน → parse และจำไว้ }
    if not VarIsEmpty(vMonth) then
    begin
      iMonth := StrToIntDef(
        Trim(StringReplace(VarToStr(vMonth), '月', '', [rfReplaceAll])),
        0
      );
      if iMonth > 0 then
        LastMonth := iMonth;   // ใช้เป็นเดือนล่าสุด
    end;

    { ถ้ายังไม่เคยเจอเดือนเลย → ข้าม }
    if (LastMonth = 0) then
      Continue;

    { ---------- Day ---------- }
    iDayStart := StrToIntDef(VarToStr(vDS), 0);
    iDayEnd   := StrToIntDef(VarToStr(vDE), 0);

    { ไม่มีวันเริ่ม → ข้ามคอลัมน์นี้ }
    if iDayStart <= 0 then
      Continue;
    { ---------- Build mapping ---------- }
    Result[Count].ColIndex := c;

    try
      Result[Count].StartDate :=
        EncodeDate(AYear, LastMonth, iDayStart);

      { ถ้าวันจบ >= วันเริ่ม → เดือนเดียวกัน }
      if iDayEnd >= iDayStart then
        Result[Count].EndDate :=
          EncodeDate(AYear, LastMonth, iDayEnd)
      else
        { คร่อมปลายเดือน (เช่น 28–3) }
        Result[Count].EndDate :=
          EncodeDate(AYear, LastMonth, iDayStart)
          + (iDayEnd - iDayStart);
    except
      Continue;
    end;

    Inc(Count);
  end;

  { resize ให้พอดีกับจำนวนที่ใช้จริง }
  SetLength(Result, Count);
end;

// ============================================================================
//   High Performance FillTemplateHeaders (Batch Processing)
// ============================================================================
procedure TForm1.FillTemplateHeaders(const AFileName: string; AYear: Integer);
var
  XLApp, WB, WS: OleVariant;
  i, k, BlockStartRow, LastRow, ColCount: Integer;
  TargetRow, TargetCol: Integer;
  
  // ตัวแปรสำหรับ Batch Process
  DataRange: OleVariant; // เก็บข้อมูล Excel ทั้งหน้าใน RAM
  RowData: TWorkRow;
  
  // ตัวช่วยจัดกลุ่มข้อมูล
  SeizoList: TStringList;
  CurrentSeizoIdx: Integer;
  
  // ตัวแปร Logic เดิม
  HeaderString, SeizoKey, ProcName: string;
  DateMaps: TDateMapArray;
  ValueToWrite, CurrentValDouble: Double;
  IsUnmanProcess: Boolean;
  CurrentValVar: OleVariant;

  // --------------------------------------------------------------------------
  // Helper: อ่านค่าจาก RAM (เร็วมาก)
  // --------------------------------------------------------------------------
  function GetVal(Row, Col: Integer): string;
  begin
    try
      // เช็คขอบเขตและค่าว่าง
      if (Row <= VarArrayHighBound(DataRange, 1)) and 
         (Col <= VarArrayHighBound(DataRange, 2)) and 
         not VarIsEmpty(DataRange[Row, Col]) then
        Result := Trim(VarToStr(DataRange[Row, Col]))
      else
        Result := '';
    except
      Result := '';
    end;
  end;

  function YearOfDT(const ADT: TDateTime): Integer;
  var Y, M, D: Word; begin if ADT <= 0 then Result := 0 else begin DecodeDate(ADT, Y, M, D); Result := Y; end; end;

  // หาบรรทัดเริ่ม Block (ค้นหาใน RAM)
  function FindNextBlockStartRow_Fast(CurRow: Integer): Integer;
  var r: Integer; s: string;
  begin
    Result := 0;
    for r := CurRow + 1 to CurRow + 2000 do
    begin
      if r > VarArrayHighBound(DataRange, 1) then Exit;
      s := GetVal(r, 2); // Col B
      if (s = '-') or (s = '－') then begin Result := r; Exit; end;
    end;
  end;

  // หาบรรทัด Process 
  function GetProcessRow_Fast(StartR: Integer; AProc: string): Integer;
  var r: Integer; s: string;
  begin
    Result := 0;
    for r := StartR to StartR + 50 do
    begin
      if r > VarArrayHighBound(DataRange, 1) then Break;
      s := GetVal(r, 2);
      if (r > StartR) and ((s = '-') or (s = '－')) then Break;
      
      s := GetVal(r, 5); // Col E = Process Name
      if SameText(s, AProc) then begin Result := r; Exit; end;
    end;
  end;

  function GetDateCol(ADate: TDateTime): Integer;
  var x: Integer;
  begin
    Result := 0;
    for x := 0 to High(DateMaps) do
      if (ADate >= DateMaps[x].StartDate) and (ADate <= DateMaps[x].EndDate) then
      begin Result := DateMaps[x].ColIndex; Exit; end;
  end;
  // --------------------------------------------------------------------------

begin
  if (FWorkDataCount <= 0) then Exit;
  // 1. จัดเตรียมข้อมูล (Pre-Group Data) เพื่อไม่ต้องวนลูป DB ซ้ำซ้อน
  SeizoList := TStringList.Create;
  try
    SeizoList.Sorted := True;
    SeizoList.Duplicates := dupIgnore;
    // เก็บเฉพาะ Order ที่ปีตรงกับที่เลือก
    for k := 0 to FWorkDataCount - 1 do
    begin
      if YearOfDT(FWorkData[k].WorkDate) = AYear then
        SeizoList.AddObject(Trim(FWorkData[k].SEIZONO), TObject(k)); // เก็บ Index ตัวอย่างไว้
    end;

    if SeizoList.Count = 0 then Exit; // ไม่มีข้อมูลปีนี้ จบงาน

    XLApp := CreateOleObject('Excel.Application');
    try
      XLApp.DisplayAlerts := False;
      WB := XLApp.Workbooks.Open(AFileName);
      try WS := WB.Worksheets[SHEET_NAME_JP]; except try WS := WB.Worksheets[SHEET_NAME_EN]; except WB.Close(False); raise Exception.Create('Error: Sheet not found.'); end; end;
      
      DateMaps := BuildDateMapping(WS, AYear);

      // ======================================================================
      //  FAST READ: อ่านข้อมูลทั้ง Sheet เ
      // ======================================================================
      LastRow := WS.Cells.SpecialCells(11).Row; // xlCellTypeLastCell
      if LastRow < 5000 then LastRow := 5000;   // เผื่อไว้
      ColCount := 200; 
      // DataRange เป็น Variant Array (1-based index)
      DataRange := WS.Range[WS.Cells[1, 1], WS.Cells[LastRow, ColCount]].Value;

      BlockStartRow := 5;
      CurrentSeizoIdx := 0;

      // เริ่มวนลูป Block (ทำงานกับ DataRange ใน RAM ล้วนๆ)
      while (BlockStartRow > 0) and (BlockStartRow < LastRow) do
      begin
        // ถ้าข้อมูลหมดแล้ว ก็จบ
        if CurrentSeizoIdx >= SeizoList.Count then Break;
         // เขียน Header
        SeizoKey := SeizoList[CurrentSeizoIdx];
        RowData := FWorkData[Integer(SeizoList.Objects[CurrentSeizoIdx])];
        HeaderString := Trim(SeizoKey + ' ' + RowData.HINNM1 + ' ' + RowData.HINNM2);
        DataRange[BlockStartRow, 3] := HeaderString;
        DataRange[BlockStartRow + 9,  4] := RowData.MfgClassific;
        DataRange[BlockStartRow + 10, 4] := RowData.DEADLINE;
        DataRange[BlockStartRow + 11, 4] := RowData.ItemCD;
        
      // --- วนลูป Data เพื่อหยอดค่า (Man/Unman) ลง RAM ---
        for k := 0 to FWorkDataCount - 1 do
        begin
            if Trim(FWorkData[k].SEIZONO) <> SeizoKey then Continue;
            if YearOfDT(FWorkData[k].WorkDate) <> AYear then Continue;

            ProcName := Trim(FWorkData[k].MeduimProcess);
            
            // หาพิกัดจาก RAM (Fast)
            TargetRow := GetProcessRow_Fast(BlockStartRow, ProcName);
            TargetCol := GetDateCol(FWorkData[k].WorkDate);

            if (TargetRow > 0) and (TargetCol > 0) then
            begin
               // Logic เดิม: เช็ค M suffix
               IsUnmanProcess := False;
               if (Length(ProcName) > 0) and (UpCase(ProcName[Length(ProcName)]) = 'M') then
               begin
                  IsUnmanProcess := True;
                  if (CompareText(ProcName, 'PGM') = 0) or (CompareText(ProcName, 'JM') = 0) then IsUnmanProcess := False;
               end;

               if IsUnmanProcess then ValueToWrite := FWorkData[k].UNMAN else ValueToWrite := FWorkData[k].MAN;

               if ValueToWrite > 0 then
               begin
                 try
                   CurrentValVar := DataRange[TargetRow, TargetCol];
                   if VarIsNumeric(CurrentValVar) then CurrentValDouble := CurrentValVar
                   else if VarIsStr(CurrentValVar) then CurrentValDouble := StrToFloatDef(Trim(CurrentValVar), 0)
                   else CurrentValDouble := 0;
                 except
                   CurrentValDouble := 0;
                 end;

                 DataRange[TargetRow, TargetCol] := CurrentValDouble + ValueToWrite;
               end;
            end
            else
            begin
               if (TargetRow = 0) and (ProcName <> '') then 
                  InsertLogData('Process not found: ' + ProcName, 1);
            end;
        end;

        Inc(CurrentSeizoIdx);
        BlockStartRow := FindNextBlockStartRow_Fast(BlockStartRow);
      end;

      if CurrentSeizoIdx < SeizoList.Count then
         InsertLogData('Warning: Template is full. Remaining items: ' + IntToStr(SeizoList.Count - CurrentSeizoIdx), 1);
      WS.Range[WS.Cells[1, 1], WS.Cells[LastRow, ColCount]].Value := DataRange;

      WB.Save;
      WB.Close(False);
    finally
      try XLApp.Quit; except end;
      XLApp := Unassigned; WB := Unassigned; WS := Unassigned;
      DataRange := Unassigned; // คืน RAM
    end;
  finally
    SeizoList.Free;
  end;
end;

procedure TForm1.ExportBlobToExcelFile(const ABlobID, AOutFile: string);
var BlobField: TBlobField; BlobStream: TStream; FileStream: TFileStream; YearInt: Integer;
begin
  qSelect.Close; qSelect.SQL.Text := 'select BINARYDATA from BLOBDATA where BLOBID = ' + QuotedStr(ABlobID); qSelect.Open;
  if qSelect.IsEmpty then
  begin InsertLogData('必要なBLOBIDがありません。', 2);
  raise Exception.Create('Blob ID ' + ABlobID + ' not found.'); end;
  BlobField := qSelect.FieldByName('BINARYDATA') as TBlobField;
  if BlobField.IsNull then raise Exception.Create('Blob ID ' + ABlobID + ' exists but contains NO DATA (NULL).');
  BlobStream := qSelect.CreateBlobStream(BlobField, bmRead);
  try FileStream := TFileStream.Create(AOutFile, fmCreate);
  try FileStream.CopyFrom(BlobStream, 0); finally FileStream.Free; end; finally BlobStream.Free; end;
  YearInt := StrToIntDef(ABlobID, 0);
  if YearInt > 0 then
   FillTemplateHeaders(AOutFile, YearInt);
end;

procedure TForm1.DoExportAll;
var
  Folder, OutFile: string;
  Years: TStringList;
  i, Y: Integer;
  OkList, FailList: TStringList;
  Msg: string;
begin
  Folder := Trim(edtPATH.Text);
  if Folder = '' then
  begin
    MessageDlg('Please select export folder first.', mtError, [mbOK], 0);
    Exit;
  end;
  if not DirectoryExists(Folder) then
  begin
    MessageDlg('Export folder not found: ' + Folder, mtError, [mbOK], 0);
    Exit;
  end;

  Years := TStringList.Create;
  OkList := TStringList.Create;
  FailList := TStringList.Create;
  try
    InsertLogData('負荷率表出力を開始します', 0);
    BuildExportYears(Years);
    for i := 0 to Years.Count - 1 do
    begin
      Y := StrToIntDef(Years[i], 0);
      if Y = 0 then Continue;
      try
        LoadWorkData(Y);
      except
        on E: Exception do
        begin
          FailList.Add('Year ' + IntToStr(Y) + ' : Failed to load data. ' + E.Message);
          InsertLogData('データロード失敗: ' + E.Message, 2);
          Continue; 
        end;
      end;

      OutFile := BuildOutFileName(Folder, Y);
      try
        ExportBlobToExcelFile(IntToStr(Y), OutFile);
        OkList.Add('Year ' + IntToStr(Y) + ' : Success');
      except
        on E: Exception do
        begin
          FailList.Add('Year ' + IntToStr(Y) + ' : ' + E.Message);
          if Pos('Blob ID', E.Message) = 0 then
            InsertLogData('内部エラー' + E.Message + 'が発生しました', 2);
        end;
      end;
    end;

    InsertLogData('負荷率表を出力しました', 0);

    // --- แสดงผลลัพธ์รวม ---
    Msg := '';
    if OkList.Count > 0 then
      Msg := Msg + '=== Success ===' + #13#10 + OkList.Text + #13#10 + #13#10;
    if FailList.Count > 0 then
      Msg := Msg + '=== Missing / Failed ===' + #13#10 + FailList.Text;

    if (OkList.Count = 0) and (FailList.Count > 0) then
      MessageDlg(Msg, mtWarning, [mbOK], 0)
    else
      MessageDlg(Msg, mtInformation, [mbOK], 0);

  finally
    Years.Free;
    OkList.Free;
    FailList.Free;
  end;
end;


end.
